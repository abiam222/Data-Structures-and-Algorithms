{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fnil\fcharset0 HelveticaNeue-BoldItalic;
}
{\colortbl;\red255\green255\blue255;\red220\green161\blue13;}
{\*\expandedcolortbl;;\cssrgb\c89412\c68627\c3922;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid102\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab560
\pard\pardeftab560\partightenfactor0

\f0\b\fs34 \cf0 HashTable, Hashing \
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0

\f1\b0\fs24 \cf0 \
\pard\pardeftab560\sa40\partightenfactor0

\f0\b\fs28 \cf0 HashTables\
\pard\pardeftab560\slleading20\partightenfactor0

\f1\b0\fs24 \cf0 \
\
\'97\'97\
\
Hashtable vs hashmap\
\
\pard\pardeftab560\slleading20\partightenfactor0

\f0\b \cf0 Hashtable
\f1\b0 \'a0is synchronized, whereas\'a0
\f0\b HashMap
\f1\b0 \'a0is not. This makes\'a0
\f0\b HashMap
\f1\b0 \'a0better for non-threaded applications, as unsynchronized Objects typically perform better than synchronized ones.\'a0
\f0\b Hashtable
\f1\b0 \'a0does not allow null keys or values.\'a0
\f0\b HashMap
\f1\b0 \'a0allows one null key\'a0
\f0\b and
\f1\b0 \'a0any number of null values.\
\
\'97\'97\
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0
\cf0 \
\
\pard\pardeftab560\slleading20\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=KyUTuwz_b7Q"}}{\fldrslt \cf2 \ul \ulc2 https://www.youtube.com/watch?v=KyUTuwz_b7Q}}\
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab560\slleading20\partightenfactor0

\f0\b \cf0 Cons\
\pard\pardeftab560\slleading20\partightenfactor0

\f1\b0 \cf0 They\'92re not always the best tool for the job - for example, they\'92re not great for finding ordered data - but sometimes, they can make our lives a lot easier.  If you\'92re doing something other than storing values at keys. Don\'92t store image pixels in a hash map. Hash maps can\'92t perform certain operations efficiently like iterating through the keys in order. This also makes things like intersections and differences trickier. If you need a persistent data structure (i.e. an immutable map) you\'92ll want to use a radix tree (trie) or search-tree based map instead. \
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab560\slleading20\partightenfactor0
\cf0 What makes a good hash table?\
\pard\pardeftab560\pardirnatural\partightenfactor0
\ls1\ilvl0\cf0 {\listtext	0.	}It should be easy to compute\
\ls1\ilvl0{\listtext	0.	}it should avoid collision\
\ls1\ilvl0{\listtext	0.	}it should use all the input data, and always return the same key for the same hash bucket per value. \
\pard\pardeftab560\slleading20\partightenfactor0
\cf0 \
\pard\pardeftab560\slleading20\partightenfactor0

\f0\b \cf0 Collision\
\pard\pardeftab560\slleading20\partightenfactor0

\f1\b0 \cf0 Occurs when two elements are supposed to be inserted at the same place in an array. \
The only situation where a collision won\'92t happen is a 
\f0\b perfect hash function, 
\f1\b0 where every single input value maps to a unique hash bucket, and no two values end up at the same key in the hash. But perfect hash functions are rare, because we usually don\'92t know how big our dataset will be before we write a hash function!\uc0\u8232 \
We have to learn how to handle collisions, because they are almost certainly going to happen. \
\
\pard\pardeftab560\slleading20\partightenfactor0

\f0\b \cf0 Collision tactics\
\pard\pardeftab560\slleading20\partightenfactor0

\f1\b0 \cf0 There are a handful of ways to handle collisions in a hash function, and the important thing to remember that none of them is necessarily the \'93right tactic\'94 to use. It depends on your data set, the size of you hash table, and what operations you know you\'92ll want to perform on the table later on. \
\
\pard\pardeftab560\pardirnatural\partightenfactor0
\ls2\ilvl0\cf0 {\listtext	0.	}
\f0\b Linear Probing\
\pard\pardeftab560\pardirnatural\partightenfactor0
\ls2\ilvl1
\f1\b0 \cf0 {\listtext	0.	}Just look for the next empty hash bucket nearby!. Kinda like, rehashing. If the next hash bucket is also filled by an element, the hash function will just continue to probe through the hash table until it finds and empty bucket, cycling back if necessary. \
\ls2\ilvl1{\listtext	0.	}The issue with this specific technique is that the act of simply moving over to the next available hash bucket and inserting an element at the \'93next free space\'94 leads to something called 
\f0\b clustering
\f1\b0  \
\ls2\ilvl1{\listtext	0.	}**A poorly designed hash table will \'93cluster\'94 a majority of its input data into only a few hash bucket. A well designed hash table will both spread its data across the hash buckets and will use the entire range of the table. \
\ls2\ilvl1{\listtext	0.	}A hash function that leads to clustering: either our hash function isn\'92t using up the entire hash table  range or its not spreading data evenly across the hash buckets of our hash table.  Both of these will lead to clustering and , as it turns out, using linear probing as a collision resolution technique can sometimes cause both of these things to happen, which leads to a clustered table \
\pard\pardeftab560\pardirnatural\partightenfactor0
\ls2\ilvl0\cf0 {\listtext	0.	}
\f0\b Chaining \
\pard\pardeftab560\pardirnatural\partightenfactor0
\ls2\ilvl1
\f1\b0 \cf0 {\listtext	0.	}What if we could just store multiple things in one hash bucket. And with the process of chaining, that exactly what we can do. \
\ls2\ilvl1{\listtext	0.	}In order to implement chaining, the hash table has to be restructured sot hat multiple elements can be stored  at one key. Hopefully you\'92ve already got an idea in hour head about what we could use here. A handy linked list \
\ls2\ilvl1{\listtext	0.	}This makes adding a single element easy - even if there is a collision (which won\'92t even be an issue anymore) We just have to add it to the front of the linked list at the appropriate hash bucket \
\ls2\ilvl1{\listtext	0.	}**Downside to chaining: it takes more time to search with more items at one location, or O(n) where n is the number of items in the hash bucket \
\ls2\ilvl1{\listtext	0.	}If your hash function does a good job of distributing elements throughout the hash table, then well be okay. In fact, if our hash function distributes any collisions evenly throughout the hash table, that means that well never end up with one long linked list that bigger than everything else. Instead we should have approximately the same size of linked list at any hash bucket where there is a collision.\
\ls2\ilvl1{\listtext	0.	}The great thing about this is that with a good hash function, chaining still average out to have a search time of O(1) or constant lookup time \
\pard\pardeftab560\slleading20\partightenfactor0
\cf0 \
	
\f0\b The power is all in the function 
\f1\b0 \
\
\
\pard\pardeftab560\slleading20\partightenfactor0

\f2\i\b \cf0 References\
\pard\pardeftab560\slleading20\partightenfactor0

\f1\i0\b0 \cf0 https://medium.com/basecs/hashing-out-hash-functions-ea5dd8beb4dd\
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0
\cf0 \
\
\pard\pardeftab560\slleading20\partightenfactor0
\cf0 class MyHashMap \{\
public:\
    int vec[1000001];\
    /** Initialize your data structure here. */\
    MyHashMap() \{\
        memset(vec, -1, 1000001);\
    \}\
    \
    /** value will always be non-negative. */\
    void put(int key, int value) \{\
        vec[key] = value;\
    \}\
    \
    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\
    int get(int key) \{\
        return vec[key];\
    \}\
    \
    /** Removes the mapping of the specified value key if this map contains a mapping for the key */\
    void remove(int key) \{\
        vec[key] = -1; \
    \}\
\};\
\
/**\
 * Your MyHashMap object will be instantiated and called as such:\
 * MyHashMap* obj = new MyHashMap();\
 * obj->put(key,value);\
 * int param_2 = obj->get(key);\
 * obj->remove(key);\
 */\
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab560\slleading20\partightenfactor0
\cf0 or\uc0\u8232 \
#define HASH_SIZE 30367 \
\
class MyHashMap \{\
public:\
    /** Initialize your data structure here. */\
    MyHashMap() \{\
        this->table =  vector<vector<pair<int, int>>>(HASH_SIZE);\
    \}\
    \
    /** value will always be non-negative. */\
    void put(int key, int value) \{\
        int loc = key % HASH_SIZE;\
        auto &vec = this->table[loc];\
        for(auto n = vec.begin(); n != vec.end(); n++) \{\
            if(n->first == key) \{\
                n->second = value;\
                return;\
            \}\
        \}\
        this->table[loc].push_back(make_pair(key, value));\
    \}\
    \
    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\
    int get(int key) \{\
        int loc = key % HASH_SIZE;\
        for(auto n: this->table[loc]) \{\
            if(n.first == key) \{\
                return n.second;\
            \}\
        \}\
        return -1;\
    \}\
    \
    /** Removes the mapping of the specified value key if this map contains a mapping for the key */\
    void remove(int key) \{\
        int loc = key % HASH_SIZE;\
        auto &vec = this->table[loc];\
        for(auto n = vec.begin(); n != vec.end(); n++) \{\
            if(n->first == key) \{\
                vec.erase(n);\
                return;\
            \}\
        \}\
    \}\
    \
    vector<vector<pair<int, int>>> table;\
\};\
\
auto gucciGang = []() \{std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;\}();\
}